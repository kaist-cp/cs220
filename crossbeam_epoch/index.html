<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Epoch-based memory reclamation."><title>crossbeam_epoch - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="crossbeam_epoch" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../crossbeam_epoch/index.html">crossbeam_epoch</a><span class="version">0.9.18</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">crossbeam_epoch</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/crossbeam_epoch/lib.rs.html#1-166">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Epoch-based memory reclamation.</p>
<p>An interesting problem concurrent collections deal with comes from the remove operation.
Suppose that a thread removes an element from a lock-free map, while another thread is reading
that same element at the same time. The first thread must wait until the second thread stops
reading the element. Only then it is safe to destruct it.</p>
<p>Programming languages that come with garbage collectors solve this problem trivially. The
garbage collector will destruct the removed element when no thread can hold a reference to it
anymore.</p>
<p>This crate implements a basic memory reclamation mechanism, which is based on epochs. When an
element gets removed from a concurrent collection, it is inserted into a pile of garbage and
marked with the current epoch. Every time a thread accesses a collection, it checks the current
epoch, attempts to increment it, and destructs some garbage that became so old that no thread
can be referencing it anymore.</p>
<p>That is the general mechanism behind epoch-based memory reclamation, but the details are a bit
more complicated. Anyhow, memory reclamation is designed to be fully automatic and something
users of concurrent collections don’t have to worry much about.</p>
<h2 id="pointers"><a class="doc-anchor" href="#pointers">§</a>Pointers</h2>
<p>Concurrent collections are built using atomic pointers. This module provides <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a>, which
is just a shared atomic pointer to a heap-allocated object. Loading an <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a> yields a
<a href="struct.Shared.html" title="struct crossbeam_epoch::Shared"><code>Shared</code></a>, which is an epoch-protected pointer through which the loaded object can be safely
read.</p>
<h2 id="pinning"><a class="doc-anchor" href="#pinning">§</a>Pinning</h2>
<p>Before an <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a> can be loaded, a participant must be <a href="fn.pin.html" title="fn crossbeam_epoch::pin"><code>pin</code></a>ned. By pinning a participant
we declare that any object that gets removed from now on must not be destructed just
yet. Garbage collection of newly removed objects is suspended until the participant gets
unpinned.</p>
<h2 id="garbage"><a class="doc-anchor" href="#garbage">§</a>Garbage</h2>
<p>Objects that get removed from concurrent collections must be stashed away until all currently
pinned participants get unpinned. Such objects can be stored into a thread-local or global
storage, where they are kept until the right time for their destruction comes.</p>
<p>There is a global shared instance of garbage queue. You can <a href="struct.Guard.html#method.defer" title="method crossbeam_epoch::Guard::defer"><code>defer</code></a> the execution of an
arbitrary function until the global epoch is advanced enough. Most notably, concurrent data
structures may defer the deallocation of an object.</p>
<h2 id="apis"><a class="doc-anchor" href="#apis">§</a>APIs</h2>
<p>For majority of use cases, just use the default garbage collector by invoking <a href="fn.pin.html" title="fn crossbeam_epoch::pin"><code>pin</code></a>. If you
want to create your own garbage collector, use the <a href="struct.Collector.html" title="struct crossbeam_epoch::Collector"><code>Collector</code></a> API.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic">Atomic</a></div><div class="desc docblock-short">An atomic pointer that can be safely shared between threads.</div></li><li><div class="item-name"><a class="struct" href="struct.Collector.html" title="struct crossbeam_epoch::Collector">Collector</a></div><div class="desc docblock-short">An epoch-based garbage collector.</div></li><li><div class="item-name"><a class="struct" href="struct.CompareExchangeError.html" title="struct crossbeam_epoch::CompareExchangeError">CompareExchangeError</a></div><div class="desc docblock-short">The error returned on failed compare-and-swap operation.</div></li><li><div class="item-name"><a class="struct" href="struct.Guard.html" title="struct crossbeam_epoch::Guard">Guard</a></div><div class="desc docblock-short">A guard that keeps the current thread pinned.</div></li><li><div class="item-name"><a class="struct" href="struct.LocalHandle.html" title="struct crossbeam_epoch::LocalHandle">LocalHandle</a></div><div class="desc docblock-short">A handle to a garbage collector.</div></li><li><div class="item-name"><a class="struct" href="struct.Owned.html" title="struct crossbeam_epoch::Owned">Owned</a></div><div class="desc docblock-short">An owned heap-allocated object.</div></li><li><div class="item-name"><a class="struct" href="struct.Shared.html" title="struct crossbeam_epoch::Shared">Shared</a></div><div class="desc docblock-short">A pointer to an object protected by the epoch GC.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.CompareAndSetOrdering.html" title="trait crossbeam_epoch::CompareAndSetOrdering">CompareAndSetOrdering</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Memory orderings for compare-and-set operations.</div></li><li><div class="item-name"><a class="trait" href="trait.Pointable.html" title="trait crossbeam_epoch::Pointable">Pointable</a></div><div class="desc docblock-short">Types that are pointed to by a single word.</div></li><li><div class="item-name"><a class="trait" href="trait.Pointer.html" title="trait crossbeam_epoch::Pointer">Pointer</a></div><div class="desc docblock-short">A trait for either <code>Owned</code> or <code>Shared</code> pointers.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.default_collector.html" title="fn crossbeam_epoch::default_collector">default_collector</a></div><div class="desc docblock-short">Returns the default global collector.</div></li><li><div class="item-name"><a class="fn" href="fn.is_pinned.html" title="fn crossbeam_epoch::is_pinned">is_pinned</a></div><div class="desc docblock-short">Returns <code>true</code> if the current thread is pinned.</div></li><li><div class="item-name"><a class="fn" href="fn.pin.html" title="fn crossbeam_epoch::pin">pin</a></div><div class="desc docblock-short">Pins the current thread.</div></li><li><div class="item-name"><a class="fn" href="fn.unprotected.html" title="fn crossbeam_epoch::unprotected">unprotected</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Returns a reference to a dummy guard that allows unprotected access to <a href="struct.Atomic.html" title="struct crossbeam_epoch::Atomic"><code>Atomic</code></a>s.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.CompareAndSetError.html" title="type crossbeam_epoch::CompareAndSetError">CompareAndSetError</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">The error returned on failed compare-and-set operation.</div></li></ul></section></div></main></body></html>